The NOVA Filesystem
===================

NOVA is a DAX file system designed to maximize performance on hybrid DRAM and
non-volatile main memory (NVMM) systems while providing strong consistency
guarantees. NOVA adapts conventional log-structured file system techniques to
exploit the fast random access that NVMs provide. In particular, it maintains
separate logs for each inode to improve concurrency, and stores file data
outside the log to minimize log size and reduce garbage collection costs. NOVA's
logs provide metadata, data, and mmap atomicity and focus on simplicity and
reliability, keeping complex metadata structures in DRAM to accelerate lookup
operations.

The main NOVA features include:

  * POSIX semantics
  * Directly access (DAX) byte-addressable NVMM without page caching
  * Per-CPU NVMM pool to maximize concurrency
  * Strong consistency guarantees with 8-byte atomic stores
  * Full filesystem snapshot with DAX-mmap support
  * Checksums on metadata and file data (crc32c)
  * Full metadata replication and RAID-5 parity per file page
  * Online filesystem integrity check and corruption recovery

Filesystem Design
=================
NOVA divides NVMM into five regions. NOVA's 512 B superblock contains global
file system information and the recovery inode. The recovery inode represents a
special file that stores recovery information (e.g., the list of unallocated
NVMM pages). NOVA divides its inode tables into per-CPU stripes. It also
provides per-CPU journals for complex file operations that involve multiple
inodes. The rest of the available NVMM stores logs and file data.

NOVA is log-structured and stores a separate log for each inode to maximize
concurrency and provide atomicity for operations that affect a single file. The
logs only store metadata and comprise a linked list of 4 KB pages. Log entries
are small – between 32 and 64 bytes. Logs are generally non-contiguous, and log
pages may reside anywhere in NVMM.

NOVA keeps read-only copies of most file metadata in DRAM during normal
operations, eliminating the need to access metadata in NVMM during reads.

NOVA uses copy-on-write to provide atomic updates for file data and appends
metadata about the write to the log. For operations that affect multiple inodes
NOVA uses lightweight, fixed-length journals – one per core.

NOVA divides the allocatable NVMM into multiple regions, one region per CPU
core. A per-core allocator manages each of the regions, minimizing contention
during memory allocation.

After a system crash, NOVA must scan all the logs to rebuild the memory
allocator state. Since, there are many logs, NOVA aggressively parallelizes the
scan.

Source File Structure
=====================
  * nova_def.h
    Defines NOVA inode, super block structures and constant macros.

  * nova.h
    Defines NOVA entry structures, DRAM data structures, macro functions,
    function prototypes, and commonly used inline functions.

  * balloc.c
    NOVA's block allocator implementation. NOVA divides NVMM into pools, one per
    CPU, and keeps lists of free NVMM pages in DRAM. NOVA uses a red-black tree
    to keep the free list sorted by address, allowing for efficient merging and
    providing O(logn) deallocation.

  * bbuild.c
    Implements recovery routines to restore the in-use inode list, the NVMM
    allocator information, and the snapshot table.

  * checksum.c
    Contains checksum-related functions to compute and verify checksums on NOVA
    data structures and file pages, and also performs recovery actions when
    corruptions are detected.

  * dax.c
    Implements DAX read/write functions to access file data. NOVA uses
    copy-on-write to modify file pages by default, unless inplace data update is
    enabled at mount-time. There are also functions to update and verify the
    file data integrity information.

  * dir.c
    Contains functions to create, update, and remove NOVA dentries.

  * file.c
    Implements file-related operations such as open, fallocate, llseek, fsync,
    and flush.

  * gc.c
    NOVA's garbage collection functions. NOVA collects stale data pages
    immediately during write operations, and NOVA uses two different garbage
    collection (GC) techniques to reclaim dead entries: Fast GC emphasizes speed
    over thoroughness and it does not require any copying. If the live entries
    account for less than 50% of the log space, NOVA applies thorough GC after
    fast GC finishes, by moving live entries to new log pages.

  * inode.c
    Creates, reads, and frees NOVA inode tables and inodes.

  * ioctl.c
    Implements some ioctl commands to call NOVA's internal functions.

  * journal.c
    For operations that affect multiple inodes NOVA uses lightweight,
    fixed-length journals – one per core. This file contains functions to
    create and manage the lite journals.

  * log.c
    Functions to manipulate NOVA inode logs, including log page allocation, log
    entry creation, commit, modification, and deletion.

  * mprotect.h
    Implements inline functions to enable/disable writing to different NOVA
    data structures.

  * mprotect.c
    When write protection is enabled, NVMM is mapped read-only into the kernel's
    address space. This file implements functions to enable/disable writes to
    NVMM via the WriteProtect Enable (WP) bit in the per-core CR0 control
    register.

  * namei.c
    Functions to create/remove files, directories, and links. It also looks for
    the NOVA inode number for a given path name.

  * parity.c
    Functions to compute file page parity bits. Each file page is striped in to
    equally sized segments (or strips), and one parity strip is calculated using
    RAID-5 method. A function to restore a broken data strip is also implemented
    in this file.

  * perf.h
    Header file for function performance measurements. It defines function IDs
    and call prototypes.

  * perf.c
    Measures primitive functions' performance, including memory copy functions
    for DRAM and NVMM, checksum functions, and XOR parity functions.

  * rebuild.c
    When mounting NOVA after a crash, rebuilds NOVA inodes from its logs. There
    are also functions to re-calculate checksums and parity bits for file pages
    that were mmapped during the crash.

  * snapshot.h
    Defines NOVA snapshot entry in NVMM and DRAM data structures that are
    relevant to managing snapshots.

  * snapshot.c
    Implements functions to create, delete and manage NOVA snapshots.

  * stats.h
    Defines data structures and macros that are relevant to gather NOVA usage
    statistics.

  * stats.c
    Implements routines to gather and print NOVA usage statistics.

  * super.c
    This file implements entry points for NOVA mounting and unmounting,
    initializing or recovering the NOVA super block and other global file system
    information.

  * symlink.c
    Implements functions to create and read symbolic links in the filesystem.

  * sysfs.c
    Implements sysfs entries to take user inputs for taking snapshots, printing
    NOVA statistics, and measuring function's performance.


FS Layout
======================
 block
+-----------------------------------------------------+
|  0  |  primary super block (struct nova_super_block)|
+-----------------------------------------------------+
|  1  | Reserved inodes                               |
+-----------------------------------------------------+
|  2  | reserved                                      |
+-----------------------------------------------------+
|  3  | Journal pointers                              |
+-----------------------------------------------------+
| 4-5 | Inode pointer tables                          |
+-----------------------------------------------------+
|  6  | reserved                                      |
+-----------------------------------------------------+
|  7  | reserved                                      |
+-----------------------------------------------------+
| ... | data pages                                    |
+-----------------------------------------------------+
| n-2 | replica reserved Inodes                       |
+-----------------------------------------------------+
| n-1 | replica super block                           |
+-----------------------------------------------------+



Superblock and Associated Structures
====================================

The beginning of the PMEM device hold the super block and its associated
tables.  These include reserved inodes, a table of pointers to the journals
Nova uses for complex operations, and pointers to inodes tables.  Nova
maintains replicas of the super block and reserved inodes in the last two
blocks of the PMEM area.


Block Allocator/Free Lists
==========================

Nova uses per-CPU allocators to manage free PMEM blocks.  On initialization,
NOVA divides the range of blocks in the PMEM device among the CPUs, and those
blocks are managed solely by that CPU.  We call these ranges of "allocation regions".

Some of the blocks in an allocation region have fixed roles.  Here's the
layout:

+-------------------------------+
| data checksum blocks          |
+-------------------------------+
| data parity blocks            |
+-------------------------------+
|                               |
| Allocatable blocks            |
|                               |
+-------------------------------+
| replica data parity blocks    |
+-------------------------------+
| replica data checksum blocks  |
+-------------------------------+

The first and last allocation regions, also contain the super block, inode
tables, etc. and their replicas, respectively.

Each allocator maintains a red-black tree of unallocated ranges (struct
nova_range_node).

Allocation Functions
--------------------

Nova allocate PMEM blocks using two mechanisms:

1.  Static allocation as defined in super.h

2.  Allocation for log and data pages via nova_new_log_blocks() and
nova_new_data_blocks().

Both of these functions allow the caller to control whether the allocator
preferes higher addresses for allocation or lower addresses.  We use this to
encourage meta data structures and their replicas to be far from one another.

PMEM Address Translation
------------------------

In Nova's persistent data structures, memory locations are given as offsets
from the beginning of the PMEM region.  nova_get_block() translates offsets to
PMEM addresses.  nova_get_addr_off() performs the reverse translation.

Inodes
======

Nova maintains per-CPU inode tables, and inode numbers are striped across the
tables (i.e., inos 0, n, 2n,... on cpu 0; inos 1, n + 1, 2n + 1, ... on cpu 1).

The inodes tables each a linked list of 2MB blocks.  The last 8 bytes of each
block points to the next block.

To allocate inodes, Nova maintains a per-cpu "inuse_list" in DRAM holds a RB
tree that holds ranges of unallocated inode numbers.

Logs
====

Nova maintains a log for each inode that records updates to the inode's
metadata and holds pointers to the file data.  Nova makes updates to file data
and metadata atomic by atomically appending log entries to the log.

Each inode contains pointers to head and tail of the inode's log.  When the log
grows past the end of the last page, nova allocates additional space.  For
short logs (less than 1MB) , it doubles the length.  For longer logs, it adds a
fixed amount of additional space (1MB).

Log space is reclaimed during garbage collection.

Log Entries
-----------

There are eight kinds of log entry, documented in log.h.  The log entries have
several entries in common:

   1.  'epoch_id' gives the epoch during which the log entry was created.
   Creating a snapshot increiments the epoch_id for the file systems.

   2.  'trans_id' is filesystem-wide, monotone increasing, number assigned each
   log entry.  It provides an ordering over all FS operations.

   3.  'invalid' is true if the effects of this entry are dead and the log
   entry can be garbage collected.

   4.  'csum' is a CRC32 checksum for the entry.

Log structure
-------------

The logs comprise a linked list of PMEM blocks.  The tail of each block

contains some metadata about the block and pointers to the next block and
block's replica (struct nova_inode_page_tail).

+----------------+
| log entry      |
+----------------+
| log entry      |
+----------------+
| ...            |
+----------------+
| tail           |
|  metadata      |
|  -> next block |
+----------------+


Journals
========

Nova uses a lightweight journaling mechanisms to provide atomicity for
operations that modify more than one on inode.  The journals providing logging
for two operations:

1.  Single word updates (JOURNAL_ENTRY)
2.  Copying inodes (JOURNAL_INODE)
                                                  
The journals are undo logs: Nova creates the journal entries for an operation,
and if the operation does not complete due to a system failure, the recovery
process rolls back the changes using the journal entries.

To commit, Nova drops the log.

Nova maintains one journal per CPU.  The head and tail pointers for each
journal live in a reserved page near the beginning of the file system.  

During recovery, Nova scans the journals and undoes the operations described by
each entry.


File and Directory Access
=========================

To access file data via read(), Nova maintains a radix tree in DRAM for each
inode (nova_inode_info_header.tree) that maps file offsets to write log
entries.  For directories, the same tree maps a hash of filenames to their
corresponding dentry.

In both cases, the nova populates the tree when the file or directory is opened
by scanning its log.

MMap and DAX
============

NOVA leverages the kernel's DAX mechanisms for mmap and file data access.  Nova
maintains a red-black tree in DRAM (nova_inode_info_header.vma_tree) to track
which portions of a file have been mapped.

Garbage Collection
==================

Nova recovers log space with a two-phase garbage collection system.  When a log
reaches the end of its allocated pages, Nova allocates more space.  Then, the
fast GC algorithm scans the log to remove pages that have no valid entries.
Then, it estimates how many pages the logs valid entries would fill.  If this
is less than half the number of pages in the log, the second GC phase copies
the valid entries to new pages.

For example:

+---+          +---+	        +---+
| I |	       | I |  	      	| V |
+---+	       +---+  Thorough	+---+
| V |	       | V |  	 GC   	| V |
+---+	       +---+   =====> 	+---+
| I |	       | I |  	      	| V |
+---+	       +---+	        +---+
| V |	       | V |  	        | V |
+---+	       +---+            +---+	
  |	         |	       
  V	         V             
+---+	       +---+ 	       
| I |	       | V | 	       
+---+	       +---+ 	       
| I | fast GC  | I | 	       
+---+  ====>   +---+ 	       
| I |	       | I | 	       
+---+	       +---+ 	       
| I |	       | V | 	       
+---+	       +---+ 	       
  |	       	
  V	       	
+---+	       	
| V |	       	
+---+	       	
| I |	       	
+---+	       	
| I |	       	
+---+	       	
| V |	       	
+---+            


Replication and Checksums
=========================

Nova protects data and metadat from corruption due to media errors and
"scribbles" -- software errors in the kernels that may overwrite Nova data.

Detection
---------

Nova uses two techniques to detect data corruption.  For media errors, Nova
should alway uses memcpy_from_pmem() to read data from PMEM.

To detect software-caused corruption, Nova uses CRC32 checksums.  All the PMEM
data structures in Nova include csum field for this purpose.  Nova also
computes CRC32 checksums each 512-byte slice of each data page.

The checksums are stored in dedicated pages in each CPU's allocation region.

                                                          replica
                                                 parity   parity 	
					         page	  page	  
            +---+---+---+---+---+---+---+---+    +---+    +---+       
data page 0 | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 |    | 0 |    | 0 |  	
            +---+---+---+---+---+---+---+---+    +---+    +---+  	
data page 1 | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 1 |    | 1 |    | 1 |  	
            +---+---+---+---+---+---+---+---+    +---+    +---+  	
data page 2 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 |    | 0 |    | 0 |  	
            +---+---+---+---+---+---+---+---+    +---+    +---+  	
data page 3 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |    | 0 |    | 0 |  	
            +---+---+---+---+---+---+---+---+    +---+    +---+  	
    ...                    ...                    ...      ...   

Recovery
--------

Nova uses replication to support recovery of metadata structures and
RAID4-style parity to recover corrupted data.

If Nova detects corruption of a metadata structure, it restores the structure
using the replica.

If it detects a corrupt slice of data page, it uses RAID4-style recovery to
restore it.  The CRC32 checksums for the page slices are replicated.

Cautious allocation
-------------------

To maximize its resilience to software scribbles, Nova allocate metadata
structures and their replicas far from one another.  It tries to allocate the
primary copy at a low address and the replica at a high address within the PMEM
region.

Write Protection
----------------

Finally, Nova supports can prevent unintended writes PMEM by mapping the entire
PMEM device as read-only and then disabling _all_ write protection by clearing
the WP bit the CR0 control register when Nova needs to perform a write.  The
wprotect mount-time option controls this behavior.


Unsafe modes
============

Nova support modes that disable some of the protections it provides to improve
perforamnce.

File data
---------

Nova can disable parity and/or checksums on file data (options 'data_parity=0'
and 'data_checksum=0').  Without parity, Nova can detect but not recover from
data corruption.  Without checksums, Nova will still detect and recover from
media errors, but not scribbles.

Nova also supports in-place file updates (option: inplace_data_updates=1).
This breaks atomicity for writes, but improve performance, especially for
sub-page writes, since these require a full page COW in the default mode.

Metadata
--------

Nova can disable metadata checksums and replication (option 'metadata_csum=0').


Snapshots
=========

Nova supports snapshots to facilitate backups.

Taking a snapshot
-----------------

Each Nova file systems has a current epoch_id in the super block and each log
entry has the epoch_id attached to it at creation.  When the user creates a
snaphot, Nova increments the epoch_id for the file system and the old epoch_id
identifies the moment the snapshot was taken.

Nova records the epoch_id and a timestamp in a new log entry (struct
snapshot_info_log_entry) and appends it to the log of the reserved snapshot
inode (NOVA_SNAPSHOT_INODE) in the superblock.

Nova also maintains a radix tree (nova_sb_info.snapshot_info_tree) of struct
snapshot_info in DRAM indexed by epoch_id.

Nova also marks all mmap'd pages as read-only and uses COW to preserve file
contents after the snapshot.

Tracking Live Data
------------------



Saving Snapshot State
---------------------

During a clean shutdown, Nova stores the snapshot information to PMEM.

Nova reserves an inode for storing snapshot information.  The log for the inode
contains an entry for each snapshot (struct snapshot_info_log_entry).  On
shutdown, Nova allocates one page (struct snapshot_nvmm_page) to store an array
of struct snapshot_nvmm_list.

Each of these lists (one per CPU) contains head and tail pointers to a linked
list of blocks (just like an inode log).  The lists contain a struct
snapshot_file_write_entry or struct snapshot_inode_entry for each operation
that modified file data or an inode.


Superblock
+--------------------+
|   ...              |
+--------------------+
| Reserved Inodes    |
+---+----------------+
|   |     ..         |
+---+----------------+
| 7 | Snapshot Inode |
|   | head           |
+---+----------------+
        /
       /
      / 
+---------+---------+---------+
|  Snap   |  Snap   |  Snap   |
| epoch=1 | epoch=4 | epoch=11|
|         |         |         |
|nvmm_page|nvmm_page|nvmm_page|
+---------+---------+---------+
     |
     |
+----------+   +--------+--------+
|  cpu 0   |   | snap 	| snap   |	
|   head   |-->| inode	| write	 |
|          |   | entry  | entry  |      
|          |   +--------+--------+
+----------+   +--------+--------+
|  cpu 1   |   | snap 	| snap   |
|   head   |-->| write	| write	 |
|          |   | entry  | entry  |
|          |   +--------+--------+
+----------+ 
|    ...   | 
+----------+   +--------+
|  cpu 128 |   | snap 	|
|   head   |-->| inode	|
|          |   | entry  |
|          |   +--------+
+----------+


Recovery
========



Allocator state
---------------


Snapshots
---------
